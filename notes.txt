Property Binding
------------------
We bind DOM properties to our component properties

There are 3 ways that Angular can translate property bindings into interpolation.
1.) <img src="{{ imageUrl }}"/>
2.) <img [src]="imageUrl" />
3.) <img bind-src="imageUrl" />

So which one should we use?
    For Dynamic Properties: lets use #1 
        - a good example is <h1>{{ title }}</h1>
        - we could do this using #2 with <h1 [textContent]="title"></h1> through accessing the DOM element.
            but we think that #1 is way cleaner
    
Property Binding works One-Way now.
- Changes in the VIEW are no longer reflected back in the component.



Class Binding
------------------

There are times when we want to add additional classes to an element based on the state of an underlying component.

        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `<button class="btn btn-primary" [class.active]="isActive">Submit</button>`
        })

        export class AppComponent() {
            isActive = true;
        }

    - in this example, we can reference the DOM element through the []
    - we point to the class attribute and then conditionally add the classname "active" based on the value of isActive


Style Binding
------------------

Similarly to Class Binding, we can actually conditionally set inline styles!!

        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `<button class="btn btn-primary" 
                [style.backgroundColor]="isActive ? 'blue' : '#6793A1'">
                    Submit
                </button>`
        })

        export class AppComponent() {
            isActive = true;
        }

Event Binding
------------------

We can bind functions in our component to events! There are two different syntactic ways to do this shown below.

        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `<button (click)="onClick()">Submit</button>
                       <button on-click="onClick()">Submit</button>
            `
        })

        export class AppComponent() {
            onClick() {
                console.log("yeah!!!");
            }
        }

If its hard to remember which does which, just remember that:
      Event Binding -------> ()     since we invoke methods with a ()
      Property Binding ----> []     since we typically access properties of an object through a [] 

What if we need to get access to the event that took place? Like, what if we need the x and y coordinates or something?
    We access this through a built in Angular parameter called $event

        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `<button (click)="onClick($event)">Submit</button>
                       <button on-click="onClick($event)">Submit</button>
            `
        })

        export class AppComponent() {

            onClick($event) {
                console.log("yeah!!!", $event.target);  // this prints out the DOM element that initiated the click
            }
        }

OK. Now lets refresh on event propogation.
When an event is emitted, the event gets propogated up until it is handled by an event handler and stops propogation.

        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `
                <div (click)="onDivClick($event)">
                    <button (click)="onClick($event)">Submit</button>
                </div>
            `
        })

        export class AppComponent() {
            onDivClick($event) {
                console.log("div event");
            }

            onClick($event) {
                console.log("button event");
            }
        }

    PRINTS OUT: 
        button event
        div event

    It does this because of EVENT BUBBLING. Neither of these two events stop the event from propogating upwards.
    Now if we did something like:


        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `
                <div (click)="onDivClick($event)">
                    <button (click)="onClick($event)">Submit</button>
                </div>
            `
        })

        export class AppComponent() {
            onDivClick($event) {
                console.log("div event");
            }

            onClick($event) {
                $event.stopPropogation()
                console.log("button event");
            }
        }

    PRINTS OUT:
        button event

    Aha, it does this because we stop the event from propogating upwards.

Two Way Binding
------------------

We use ngModel to bind a DOM (View) property to a Component Property.

    WITHOUT NGMODEL
        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `<input type="text" 
                [value]=title                                   // property binding
                (input)="title = $event.target.value" />        // event binding
                Preview -- {{ title }}
            `
        })

        export class AppComponent() {
            title = "Angular App"
        } 

    - This is how we do two-way binding in Angular2 WITHOUT NGMODEL
    - there is an (input) action on an input field, when the event happens, we want to set component value to equal 
        the value of the DOM element.
    
    WITH NGMODEL   
        import {Component} from  'angular2/core'

        @Component({
            selector: 'my-app',
            template: `
                <input type="text" [(ngModel)]="title"/> // applys BOTH Event binding AND property binding
                <input type="text" bindon-ngModel="title"/> // another way to do it 
            `
        })

        export class AppComponent() {
            title = "Angular App"
        }     

    - Therefore, in Angular2, we don't have 2 way binding. We have one way binding. This is inherited from Flux architecture and
        ensures that our apps are more predictable and easier to debug when things go wrong.
    

Create a component called Tweet
    - this will render the picture and the heart and the twitter handle and the text
    - use Media Object from bootstrap for the picture. Use the Template Layout like we say earlier
    - http://lorempixel.com/100/100/people?1 : to get a random picture
    - create a service that returns a list of tweets (just hard code the tweet objects)
    - use DI to inject the service into the 
    - use *ngFor="#course from courses"


